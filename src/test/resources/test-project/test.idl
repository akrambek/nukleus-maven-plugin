/*
 * Copyright 2016-2017 The Reaktivity Project
 *
 * The Reaktivity Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
scope test
{

    scope inner {
        //option byte_order native;
        
        struct FlatParent
        {
            uint64 fixed1;
        }

        struct Flat extends FlatParent [0x10000001]
        {
            uint16 fixed2 = 222;
            string string1;
            uint24 fixed3 = 333;
            string string2;
            int32 fixed4 = 444;
            string string3;
        }

        struct Nested
        {
            uint64 fixed4 = 444;
            Flat flat;
            int64 fixed5;
        }

        struct FlatWithArray
        {
            uint64 fixed1 = 111;
            string string1;
            string[] array1;
            int32 fixed2 = 5;
        }

        struct FlatWithOctets
        {
            uint32 fixed1 = 11;
            octets[10] octets1;
            uint16 lengthOctets2;
            string string1;
            octets[lengthOctets2] octets2;
            varbyteuint32 lengthOctets3;
            octets[lengthOctets3] octets3 = null;
            int32 lengthOctets4;
            octets[lengthOctets4] octets4 = null;
            int24 lengthOctets5;
            octets[lengthOctets5] octets5 = null;
            octets extension;
        }

        struct OctetsDefaultedNoAnchor
        {
            int32 length;
            octets[length] payload = null;
            octets extension;
        }

//        list[uint32, uint32] ListWithPhysicalAndLogicalLength
//        {
//            required string field0;
//            uint32 field1;
//            string field2;
//        }

        union UnionOctets switch (uint8)
        {
            case 1: octets[4] octets4;
            case 2: octets[16] octets16;
            case 3: string string1;
        }

        variant VariantUint8KindWithUint64Type switch (uint8) of uint64
        {
            case 0x80: uint64;
            case 0x53: uint8;
            case 0x44: 0;
            case 0x01: 1;
            case 0x70: uint32;
            case 0x60: uint16;
            case 0x50: uint24;
        }

        variant VariantUint8KindWithString32Type switch (uint8) of string32
        {
           case 0xa1: string;
           case 0x16: string16;
           case 0xb1: string32;
        }

        variant VariantUnsignedIntWithoutExplicitType switch (uint8)
        {
           case 0x70: uint32;
           case 0x50: uint24;
           case 0x52: uint8;
           case 0x43: 0;
        }

        variant VariantUint8KindWithInt64Type switch (uint8) of int64
        {
            case 0x71: int32;
            case 0x81: int64;
            case 0x50: int24;
            case 0x51: int8;
            case 0x61: int16;
        }

        struct Integers
        {
            uint8  unsigned8  = 0xFF;
            uint16 unsigned16 = 0xFFFF;
            uint24 unsigned24 = 0xFFFFFF;
            uint32 unsigned32 = 0x7FFFFFFF; // TODO: 0xFFFFFFFF;
            uint64 unsigned64 = 0x7FFFFFFF; // TODO: 0xFFFFFFFFFFFFFFFF;
            varbyteuint32 varuint32 = 123;
            varint32 variable32 = 123;
            int8  signed8  =  -8;
            int16 signed16 = -16;
            int24 signed24 = -24;
            int32 signed32 = -32;
            int64 signed64 = -64;
            varint64 variable64 = -234;
        }

        struct IntegerFixedArrays
        {
            uint8[1]  uint8Array;
            uint16[2] uint16Array;
            uint24[3] uint24Array;
            uint32[4] uint32Array;
            uint64[8] uint64Array;
            string anchor;
            int8[1]  int8Array;
            int16[2] int16Array;
            int24[3] int24Array;
            int32[4] int32Array;
            int64[8] int64Array;
        }

        struct IntegerVariableArrays
        {
            uint8  fixed1 = 0;
            int32 lengthUnsigned64;
            int16 fixed2 = 0;
            varint32[] varint32Array;
            uint64[lengthUnsigned64] unsigned64Array = null;
            uint8 lengthSigned16;
            int16[lengthSigned16] signed16Array;
            uint8 lengthSigned24;
            int24[lengthSigned24] signed24Array;
            varint64[] varint64Array;
            int8 lengthInt8;
            int32[lengthInt8] arrayWithInt8Size = null;
            int16 lengthInt16;
            int32[lengthInt16] arrayWithInt16Size = null;
            int24 lengthInt24;
            int32[lengthInt24] arrayWithInt24Size = null;
        }

        struct NestedAllDefaulting
        {
            uint8 fixed1 = 11;
            Integers integers;
        }

        enum Roll
        {
            EGG,
            SPRING,
            FORWARD
        }

        enum EnumWithInt8 (int8)
        {
            ONE (1),
            TWO (2),
            THREE (3)
        }

        enum EnumWithInt16 (int16)
        {
            ONE (1),
            TWO (2),
            THREE (3)
        }

        enum EnumWithInt32 (int32)
        {
            ONE (1),
            TWO (2),
            THREE (3)
        }

        enum EnumWithInt64 (int64)
        {
            TEN (0x10L),
            ELEVEN (0x11L),
            TWELVE (0x12L)
        }

        enum EnumWithUint8 (uint8)
        {
            ICHI (201),
            NI (202),
            SAN (203)
        }

        enum EnumWithUint16 (uint16)
        {
            ICHI (60001),
            NI (60002),
            SAN (60003)
        }

        enum EnumWithUint32 (uint32)
        {
            ICHI (4000000001L),
            NI (4000000002L),
            SAN (4000000003L)
        }

        enum EnumWithUint64 (uint64)
        {
            ICHI (4000000001L),
            NI (4000000002L),
            SAN (4000000003L)
        }

        enum EnumWithString (string)
        {
            BLUE ("blue"),
            RED ("red"),
            YELLOW ("yellow")
        }

        enum EnumWithString16 (string16)
        {
            BLUE ("blue"),
            RED ("red"),
            YELLOW ("yellow")
        }

        enum EnumWithString32 (string32)
        {
            BLUE ("blue"),
            RED ("red"),
            YELLOW ("yellow")
        }

        struct PotentialNameConflicts
        {
           string value;
           int32 newLimit;
           string buffer;
           octets[10] offset;
           string limit;
        }

        struct ContiguousSizeFields
        {
            int8 length1;
            int8 length2;
            int8[length1] array1 = null;
            int8[length2] array2 = null;
            string string1;
            int8 length3;
            int8 length4;
            int8[length3] array3 = null;
            int8[length4] array4 = null;
        }

        variant VariantEnumKindWithInt32 switch (EnumWithInt8) of int32
        {
            case ONE: int8;
            case TWO: int16;
            case THREE: int32;
        }

        variant VariantEnumKindWithString32 switch (EnumWithInt8) of string32
        {
            case ONE: string;
            case TWO: string16;
            case THREE: string32;
        }

        variant VariantEnumKindOfInt8 switch (EnumWithInt8) of int8
        {
            case ONE: int8;
            case TWO: 0;
            case THREE: 1;
        }

        variant VariantEnumKindOfInt16 switch (EnumWithInt16) of int16
        {
            case ONE: 0;
            case TWO: int8;
            case THREE: int16;
        }

        variant VariantEnumKindOfUint8 switch (EnumWithUint8) of uint8
        {
            case ICHI: uint8;
            case NI: 0;
            case SAN: 1;
        }

        variant VariantEnumKindOfUint16 switch (EnumWithUint16) of uint16
        {
            case ICHI: uint16;
            case NI: uint8;
            case SAN: 0;
        }

        variant VariantEnumKindOfUint32 switch (EnumWithUint32) of uint32
        {
            case ICHI: 0;
            case NI: uint32;
            case SAN: 1;
        }
    }
}
